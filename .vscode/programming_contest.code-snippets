{
    // Place your coding-problems workspace snippets here. Each snippet is defined under a snippet name and has a scope, prefix, body and
    // description. Add comma separated ids of the languages where the snippet is applicable in the scope field. If scope
    // is left empty or omitted, the snippet gets applied to all languages. The prefix is what is
    // used to trigger the snippet and the body will be expanded and inserted. Possible variables are:
    // $1, $2 for tab stops, $0 for the final cursor position, and ${1:label}, ${2:another} for placeholders.
    // Placeholders with the same ids are connected.
    // Example:
    "GCD": {
        "scope": "python",
        "prefix": "gcd",
        "body": [
            "def gcd(a, b):",
            "    if b == 0:",
            "        return a",
            "    return gcd(b, a % b)",
            "",
            "",
            "def gcd_n(a, n):",
            "    ans = a[0]",
            "    for i in range(1, n):",
            "        ans = gcd(ans, A[i])",
            "    return ans"
        ],
        "description": "greatest common divisor (最大公約数)"
    },
    "LCM": {
        "scope": "python",
        "prefix": "lcm",
        "body": [
            "def gcd(a, b):",
            "    if b == 0:",
            "        return a",
            "    return gcd(b, a % b)",
            "",
            "",
            "def lcm(a, b):",
            "    return a*b // gcd(a, b)",
            "",
            "",
            "def lcm_n(a, n):",
            "    ans = a[0]",
            "    for i in range(1, n):",
            "        ans = lcm(ans, A[i])",
            "    return ans"
        ],
        "description": "least common multiple (最小公倍数)"
    },
    "prime": {
        "scope": "python",
        "prefix": "prime",
        "body": [
            "def primes(n):",
            "    is_prime = [1] * (n + 1)",
            "    is_prime[0] = 0",
            "    is_prime[1] = 0",
            "    for i in range(2, int(n**0.5) + 1):",
            "        if not is_prime[i]:",
            "            continue",
            "        for j in range(i * 2, n + 1, i):",
            "            is_prime[j] = 0",
            "    return is_prime",
            "",
            "",
            "def is_prime(n):",
            "    if n == 1:",
            "        return False",
            "    for i in range(2, int(n**0.5)+1):",
            "        if n % i == 0:",
            "             return False",
            "    return True",
            "",
            "",
            "def gcd(a, b):",
            "    if b == 0:",
            "        return a",
            "    return gcd(b, a % b)",
            "",
            "",
            "def coprime(a, b):",
            "    return gcd(a, b) == 1"
        ],
        "description": "prime number (素数)"
    },
    "divisor": {
        "scope": "python",
        "prefix": "divisor",
        "body": [
            "def divisor(n):",
            "    ret = []",
            "    for i in range(1, int(n**0.5)+1):",
            "        if n % i == 0:",
            "            ret.append(i)",
            "            if n // i != i:",
            "                ret.append(n // i)",
            "    return ret",
        ],
        "description": "divisor (約数)"
    },
    "factorization": {
        "scope": "python",
        "prefix": "factorization",
        "body": [
            "def factorization(n):",
            "    if n <= 1:",
            "        return []",
            "",
            "    ret = []",
            "    while n > 2 and n % 2 == 0:",
            "        ret.append(2)",
            "        n //= 2",
            "    i = 3",
            "    while i <= math.sqrt(n):",
            "        if n % i == 0:",
            "            ret.append(i)",
            "            n //= i",
            "        else:",
            "            i += 2",
            "    ret.append(n)",
            "    return ret",
        ],
        "description": "factorization (素因数分解)"
    },
    "digsum": {
        "scope": "python",
        "prefix": "digsum",
        "body": [
            "def digsum(n):",
            "    s = 0",
            "    while n:",
            "        s += n % 10",
            "        n //= 10",
            "    return s",
        ],
        "description": "digsum (桁数)"
    },
    "modinv": {
        "scope": "python",
        "prefix": "modinv",
        "body": [
            "def modinv(a):",
            "    return pow(a, MOD-2, MOD)",
        ],
        "description": "modinv (MODの逆元)"
    },
    "bfs_graph": {
        "scope": "python",
        "prefix": "bfs_graph",
        "body": [
            "def bfs(graph, initial):",
            "    n = len(graph) - 1",
            "    dist = [-1] * (n + 1)",
            "    q = deque([initial])",
            "    visited = [False] * (n + 1)",
            "    visited[initial] = True",
            "    dist[initial] = 0",
            "",
            "    while len(q) != 0:",
            "        edge = q.popleft()",
            "        nxt = graph[edge]",
            "",
            "        for i, e in enumerate(nxt):",
            "            if visited[e] is False:",
            "                q.append(e)",
            "                dist[e] = dist[edge] + 1",
            "                visited[e] = True",
            "",
            "    return dist",
            "",
            "",
            "def main():",
            "    N, M = MI()",
            "    graph = [[] for i in range(N+1)]",
            "",
            "    for i in range(M):",
            "        x, y = MI()",
            "        graph[x].append(y)",
            "        graph[y].append(x)",
            "",
            "    ret = bfs(graph, 1)",
            "    print(ret)",
        ],
        "description": "BFS (graph)"
    },
    "bfs_maze": {
        "scope": "python",
        "prefix": "bfs_maze",
        "body": [
            "BLOCK = '#'",
            "ROAD = '.'",
            "",
            "",
            "def bfs(graph, initial, goal, H, W):",
            "    options = [(-1, 0), (0, 1), (1, 0), (0, -1)]",
            "    q = deque([initial])",
            "    visited = [[False for i in range(W)] for i in range(H)]",
            "    dist = [[-1 for i in range(W)] for i in range(H)]",
            "    visited[initial[0]][initial[1]] = True",
            "    dist[initial[0]][initial[1]] = 0",
            "",
            "    while len(q) != 0:",
            "        p = q.popleft()",
            "",
            "        for d in options:",
            "            i = p[0] + d[0]",
            "            j = p[1] + d[1]",
            "",
            "            if i >= 0 and i < H and j >= 0 and j < W and not visited[i][j] and graph[i][j] != BLOCK:",
            "                visited[i][j] = True",
            "                q.append((i, j))",
            "                dist[i][j] = dist[p[0]][p[1]] + 1",
            "",
            "    return dist[goal[0]][goal[1]]",
            "",
            "",
            "def main():",
            "    H, W = MI()",
            "    graph = [None] * H",
            "",
            "    for i in range(H):",
            "        graph[i] = list(S())",
            "",
            "        for j in range(W):",
            "            if graph[i][j] == 'S':",
            "                pass",
            "",
            "    ret = bfs(graph, (0, 0), (1, 1), H, W)",
            "    print(ret)",
        ],
        "description": "BFS (maze)"
    },
    "bfs_maze_hexa": {
        "scope": "python",
        "prefix": "bfs_maze_hexa",
        "body": [
            "def bfs(graph, initial, H, W):",
            "    odd_options = [(-1, 0), (-1, -1), (0, -1), (1, -1), (1, 0), (0, 1)]",
            "    even_options = [(-1, 0), (-1, 1), (0, 1), (1, 1), (1, 0), (0, -1)]",
            "    visited = [[False for i in range(W)] for i in range(H)]",
            "    dist = [[-1 for i in range(W)] for i in range(H)]",
            "    visited[initial[0]][initial[1]] = True",
            "    dist[initial[0]][initial[1]] = 0",
            "    q = deque([initial])",
            "",
            "    while len(q) != 0:",
            "        p = q.popleft()",
            "",
            "        options = even_options if p[0] % 2 == 0 else odd_options",
            "        for d in options:",
            "            i = p[0] + d[0]",
            "            j = p[1] + d[1]",
            "",
            "            if i >= 0 and i < H and j >= 0 and j < W and not visited[i][j] and graph[i][j] == 1:",
            "                visited[i][j] = True",
            "                q.append((i, j))",
            "                dist[i][j] = dist[p[0]][p[1]] + 1",
            "",
            "    return dist",
            "",
            "",
            "def main():",
            "    H, W = MI()",
            "    graph = [None] * H",
            "",
            "    for i in range(H):",
            "        graph[i] = LI()",
            "",
            "    ret = bfs(graph, (0, 1), H, W)",
            "    print(ret)",
        ],
        "description": "BFS (maze hexa)"
    },
}
