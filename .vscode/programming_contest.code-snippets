{
    // Place your coding-problems workspace snippets here. Each snippet is defined under a snippet name and has a scope, prefix, body and
    // description. Add comma separated ids of the languages where the snippet is applicable in the scope field. If scope
    // is left empty or omitted, the snippet gets applied to all languages. The prefix is what is
    // used to trigger the snippet and the body will be expanded and inserted. Possible variables are:
    // $1, $2 for tab stops, $0 for the final cursor position, and ${1:label}, ${2:another} for placeholders.
    // Placeholders with the same ids are connected.
    // Example:
    "Print to console": {
        "scope": "cpp",
        "prefix": "cpptemplate",
        "body": [
            "#include <bits/stdc++.h>",
            "typedef long long ll;",
            "using namespace std;",
            "#define DUMP(x)  cout << #x << \" = \" << (x) << endl;",
            "#define FOR(i, m, n) for(ll i = m; i < n; i++)",
            "#define IFOR(i, m, n) for(ll i = n - 1; i >= m; i-- )",
            "#define REP(i, n) FOR(i,0,n)",
            "#define IREP(i, n) IFOR(i,0,n)",
            "#define FOREACH(x,a) for(auto& (x) : (a) )",
            "#define ALL(v) (v).begin(), (v).end()",
            "#define SZ(x) ll(x.size())",
            "",
            "template <typename _Ty>",
            "ostream& operator << (ostream& ostr, const vector<_Ty>& v) {",
            "    if (v.empty()) {",
            "        ostr << \"{ }\";",
            "        return ostr;",
            "    }",
            "    ostr << \"{\" << v.front();",
            "    for (auto itr = ++v.begin(); itr != v.end(); itr++) {",
            "        ostr << \", \" << *itr;",
            "    }",
            "    ostr << \"}\";",
            "    return ostr;",
            "}",
            "",
            "const ll MOD = 1e9+7;",
            "",
            "using namespace std;",
            "",
            "int main() {",
            "   cin.tie(0);",
            "   ios_base::sync_with_stdio(false);",
            "",
            "   return 0;",
            "}"
        ],
        "description": "cpp_template"
    },
    "array_n": {
        "scope": "python",
        "prefix": "array_n",
        "body": [
            "x = [0] * N"
        ],
        "description": "greatest common divisor (最大公約数)"
    },
    "GCD": {
        "scope": "python",
        "prefix": "gcd",
        "body": [
            "def gcd(a, b):",
            "    if b == 0:",
            "        return a",
            "    return gcd(b, a % b)",
            "",
            "",
            "def gcd_n(a, n):",
            "    ans = a[0]",
            "    for i in range(1, n):",
            "        ans = gcd(ans, A[i])",
            "    return ans"
        ],
        "description": "greatest common divisor (最大公約数)"
    },
    "LCM": {
        "scope": "python",
        "prefix": "lcm",
        "body": [
            "def gcd(a, b):",
            "    if b == 0:",
            "        return a",
            "    return gcd(b, a % b)",
            "",
            "",
            "def lcm(a, b):",
            "    return a*b // gcd(a, b)",
            "",
            "",
            "def lcm_n(a, n):",
            "    ans = a[0]",
            "    for i in range(1, n):",
            "        ans = lcm(ans, A[i])",
            "    return ans"
        ],
        "description": "least common multiple (最小公倍数)"
    },
    "prime": {
        "scope": "python",
        "prefix": "prime",
        "body": [
            "def primes(n):",
            "    is_prime = [1] * (n + 1)",
            "    is_prime[0] = 0",
            "    is_prime[1] = 0",
            "    for i in range(2, int(n**0.5) + 1):",
            "        if not is_prime[i]:",
            "            continue",
            "        for j in range(i * 2, n + 1, i):",
            "            is_prime[j] = 0",
            "    return is_prime",
            "",
            "",
            "def is_prime(n):",
            "    if n == 1:",
            "        return False",
            "    for i in range(2, int(n**0.5)+1):",
            "        if n % i == 0:",
            "             return False",
            "    return True",
            "",
            "",
            "def gcd(a, b):",
            "    if b == 0:",
            "        return a",
            "    return gcd(b, a % b)",
            "",
            "",
            "def coprime(a, b):",
            "    return gcd(a, b) == 1"
        ],
        "description": "prime number (素数)"
    },
    "divisor": {
        "scope": "python",
        "prefix": "divisor",
        "body": [
            "def divisor(n):",
            "    ret = []",
            "    for i in range(1, int(n**0.5)+1):",
            "        if n % i == 0:",
            "            ret.append(i)",
            "            if n // i != i:",
            "                ret.append(n // i)",
            "    return ret",
        ],
        "description": "divisor (約数)"
    },
    "factorization": {
        "scope": "python",
        "prefix": "factorization",
        "body": [
            "def factorization(n):",
            "    if n <= 1:",
            "        return []",
            "",
            "    ret = []",
            "    while n > 2 and n % 2 == 0:",
            "        ret.append(2)",
            "        n //= 2",
            "    i = 3",
            "    while i <= math.sqrt(n):",
            "        if n % i == 0:",
            "            ret.append(i)",
            "            n //= i",
            "        else:",
            "            i += 2",
            "    ret.append(n)",
            "    return ret",
        ],
        "description": "factorization (素因数分解)"
    },
    "digsum": {
        "scope": "python",
        "prefix": "digsum",
        "body": [
            "def digsum(n):",
            "    s = 0",
            "    while n:",
            "        s += n % 10",
            "        n //= 10",
            "    return s",
        ],
        "description": "digsum (桁数)"
    },
    "modinv": {
        "scope": "python",
        "prefix": "modinv",
        "body": [
            "def modinv(a):",
            "    return pow(a, MOD-2, MOD)",
        ],
        "description": "modinv (MODの逆元)"
    },
    "bfs_graph": {
        "scope": "python",
        "prefix": "bfs_graph",
        "body": [
            "def bfs(graph, initial):",
            "    n = len(graph) - 1",
            "    dist = [-1] * (n + 1)",
            "    q = deque([initial])",
            "    visited = [False] * (n + 1)",
            "    visited[initial] = True",
            "    dist[initial] = 0",
            "",
            "    while len(q) != 0:",
            "        edge = q.popleft()",
            "        nxt = graph[edge]",
            "",
            "        for i, e in enumerate(nxt):",
            "            if visited[e] is False:",
            "                q.append(e)",
            "                dist[e] = dist[edge] + 1",
            "                visited[e] = True",
            "",
            "    return dist",
            "",
            "",
            "def main():",
            "    N, M = MI()",
            "    graph = [[] for i in range(N+1)]",
            "",
            "    for i in range(M):",
            "        x, y = MI()",
            "        graph[x].append(y)",
            "        graph[y].append(x)",
            "",
            "    ret = bfs(graph, 1)",
            "    print(ret)",
        ],
        "description": "BFS (graph)"
    },
    "bfs_maze": {
        "scope": "python",
        "prefix": "bfs_maze",
        "body": [
            "BLOCK = '#'",
            "ROAD = '.'",
            "",
            "",
            "def bfs(graph, initial, goal, H, W):",
            "    options = [(-1, 0), (0, 1), (1, 0), (0, -1)]",
            "    q = deque([initial])",
            "    visited = [[False for i in range(W)] for i in range(H)]",
            "    dist = [[-1 for i in range(W)] for i in range(H)]",
            "    visited[initial[0]][initial[1]] = True",
            "    dist[initial[0]][initial[1]] = 0",
            "",
            "    while len(q) != 0:",
            "        p = q.popleft()",
            "",
            "        for d in options:",
            "            i = p[0] + d[0]",
            "            j = p[1] + d[1]",
            "",
            "            if i >= 0 and i < H and j >= 0 and j < W and not visited[i][j] and graph[i][j] != BLOCK:",
            "                visited[i][j] = True",
            "                q.append((i, j))",
            "                dist[i][j] = dist[p[0]][p[1]] + 1",
            "",
            "    return dist[goal[0]][goal[1]]",
            "",
            "",
            "def main():",
            "    H, W = MI()",
            "    graph = [None] * H",
            "",
            "    for i in range(H):",
            "        graph[i] = list(S())",
            "",
            "        for j in range(W):",
            "            if graph[i][j] == 'S':",
            "                pass",
            "",
            "    ret = bfs(graph, (0, 0), (1, 1), H, W)",
            "    print(ret)",
        ],
        "description": "BFS (maze)"
    },
    "bfs_maze_hexa": {
        "scope": "python",
        "prefix": "bfs_maze_hexa",
        "body": [
            "def bfs(graph, initial, H, W):",
            "    odd_options = [(-1, 0), (-1, -1), (0, -1), (1, -1), (1, 0), (0, 1)]",
            "    even_options = [(-1, 0), (-1, 1), (0, 1), (1, 1), (1, 0), (0, -1)]",
            "    visited = [[False for i in range(W)] for i in range(H)]",
            "    dist = [[-1 for i in range(W)] for i in range(H)]",
            "    visited[initial[0]][initial[1]] = True",
            "    dist[initial[0]][initial[1]] = 0",
            "    q = deque([initial])",
            "",
            "    while len(q) != 0:",
            "        p = q.popleft()",
            "",
            "        options = even_options if p[0] % 2 == 0 else odd_options",
            "        for d in options:",
            "            i = p[0] + d[0]",
            "            j = p[1] + d[1]",
            "",
            "            if i >= 0 and i < H and j >= 0 and j < W and not visited[i][j] and graph[i][j] == 1:",
            "                visited[i][j] = True",
            "                q.append((i, j))",
            "                dist[i][j] = dist[p[0]][p[1]] + 1",
            "",
            "    return dist",
            "",
            "",
            "def main():",
            "    H, W = MI()",
            "    graph = [None] * H",
            "",
            "    for i in range(H):",
            "        graph[i] = LI()",
            "",
            "    ret = bfs(graph, (0, 1), H, W)",
            "    print(ret)",
        ],
        "description": "BFS (maze hexa)"
    },
    "bit_full_search": {
        "scope": "python",
        "prefix": "bit_full_search",
        "body": [
            "for i in range(2 ** N):",
            "    groups = set()",
            "    for j in range(N):",
            "        if ((i >> j) & 1):",
            "            groups.add(j+1)",
            "    pass",
        ],
        "description": "Bit Full Search"
    },
    "UnionFind": {
        "scope": "python",
        "prefix": "UnionFind",
        "body": [
            "class UnionFind(object):",
            "    def __init__(self, n):",
            "        self.n = n",
            "        self.parents = [-1] * n",
            "",
            "    def find(self, x):",
            "        if self.parents[x] < 0:",
            "            return x",
            "        else:",
            "            self.parents[x] = self.find(self.parents[x])",
            "            return self.parents[x]",
            "",
            "    def union(self, x, y):",
            "        x = self.find(x)",
            "        y = self.find(y)",
            "",
            "        if x == y:",
            "            return",
            "",
            "        if self.parents[x] > self.parents[y]:",
            "            x, y = y, x",
            "",
            "        self.parents[x] += self.parents[y]",
            "        self.parents[y] = x",
            "",
            "    def size(self, x):",
            "        return -self.parents[self.find(x)]",
            "",
            "    def same(self, x, y):",
            "        return self.find(x) == self.find(y)",
            "",
            "    def members(self, x):",
            "        root = self.find(x)",
            "        return [i for i in range(self.n) if self.find(i) == root]",
            "",
            "    def roots(self):",
            "        return [i for i, x in enumerate(self.parents) if x < 0]",
            "",
            "    def group_count(self):",
            "        return len(self.roots())",
            "",
            "    def all_group_members(self):",
            "        return {r: self.members(r) for r in self.roots()}",
            "",
            "    def __str__(self):",
            "        return '\\n'.join('{}: {}'.format(r, self.members(r)) for r in self.roots()),",
        ],
        "description": "Bit Full Search"
    },
    "cmb_modinv": {
        "scope": "python",
        "prefix": "cmb_modinv",
        "body": [
            "def modinv(a):",
            "    return pow(a, MOD - 2, MOD)",
            "",
            "",
            "def cmb(n, r):",
            "    p = 1",
            "    c = 1",
            "    for i in range(r):",
            "        p *= (n - i)",
            "        c *= (i + 1)",
            "        p = p % MOD",
            "        c = c % MOD",
            "    return p * modinv(c) % MOD",
        ],
        "description": "Conbination mod inv"
    },
    "factorial_mod": {
        "scope": "python",
        "prefix": "factorial_mod",
        "body": [
            "def modinv(a):",
            "    return pow(a, MOD - 2, MOD)",
            "",
            "",
            "def factorial(n):",
            "    ret = 1",
            "    for i in range(1, n+1):",
            "        ret *= i",
            "        ret %= MOD",
            "    return ret",
        ],
        "description": "Conbination mod inv"
    },
    "warshall_floyd": {
        "scope": "python",
        "prefix": "warshall_floyd",
        "body": [
            "def warshall_floyd(d, n):",
            "    for k in range(n):",
            "        for i in range(n):",
            "            for j in range(n):",
            "                d[i][j] = min(d[i][j], d[i][k] + d[k][j])",
            "    return d",
            "",
            "",
            "def main():",
            "    N, M = MI()",
            "    d = [[IINF] * N for i in range(N)]",
            "",
            "    for i in range(M):",
            "        a, b, t = MI()",
            "        d[a-1][b-1] = t",
            "        d[b-1][a-1] = t",
            "",
            "    for i in range(N):",
            "        d[i][i] = 0",
            "",
            "    d = warshall_floyd(d, N)",
            "",
            "    print_matrix(d)",
        ],
        "description": "Warshall Floyd"
    },
    "distance": {
        "scope": "python",
        "prefix": "distance",
        "body": [
            "def distance(x1, y1, x2, y2):",
            "    return math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)",
        ],
        "description": "Warshall Floyd"
    },
    "binary_search": {
        "scope": "python",
        "prefix": "binary_search",
        "body": [
            "def f(x):",
            "    return x",
            "",
            "",
            "# 二分探索 ok ng",
            "def main():",
            "    A, B, X = MI()",
            "    s = 1",
            "    t = 10**9 + 1",
            "    ok = s - 1",
            "    ng = t",
            "",
            "    while ng - ok > 1:",
            "        mid = (ng + ok) // 2",
            "        if f(mid) <= X:",
            "            ok = mid",
            "        else:",
            "            ng = mid",
            "",
            "    print(ok)"
        ],
        "description": "Warshall Floyd"
    }
}
