{
    // Place your coding-problems workspace snippets here. Each snippet is defined under a snippet name and has a scope, prefix, body and
    // description. Add comma separated ids of the languages where the snippet is applicable in the scope field. If scope
    // is left empty or omitted, the snippet gets applied to all languages. The prefix is what is
    // used to trigger the snippet and the body will be expanded and inserted. Possible variables are:
    // $1, $2 for tab stops, $0 for the final cursor position, and ${1:label}, ${2:another} for placeholders.
    // Placeholders with the same ids are connected.
    // Example:
    "Print to console": {
        "scope": "cpp",
        "prefix": "cpptemplate",
        "body": [
            "#include <bits/stdc++.h>",
            "typedef long long ll;",
            "using namespace std;",
            "#define DUMP(x)  cout << #x << \" = \" << (x) << endl;",
            "#define FOR(i, m, n) for(ll i = m; i < n; i++)",
            "#define IFOR(i, m, n) for(ll i = n - 1; i >= m; i-- )",
            "#define REP(i, n) FOR(i,0,n)",
            "#define IREP(i, n) IFOR(i,0,n)",
            "#define FOREACH(x,a) for(auto& (x) : (a) )",
            "#define ALL(v) (v).begin(), (v).end()",
            "#define SZ(x) ll(x.size())",
            "",
            "template <typename _Ty>",
            "ostream& operator << (ostream& ostr, const vector<_Ty>& v) {",
            "    if (v.empty()) {",
            "        ostr << \"{ }\";",
            "        return ostr;",
            "    }",
            "    ostr << \"{\" << v.front();",
            "    for (auto itr = ++v.begin(); itr != v.end(); itr++) {",
            "        ostr << \", \" << *itr;",
            "    }",
            "    ostr << \"}\";",
            "    return ostr;",
            "}",
            "",
            "const ll MOD = 1e9+7;",
            "",
            "using namespace std;",
            "",
            "int main() {",
            "   cin.tie(0);",
            "   ios_base::sync_with_stdio(false);",
            "",
            "   return 0;",
            "}"
        ],
        "description": "cpp_template"
    },
    "array_n": {
        "scope": "python",
        "prefix": "array_n",
        "body": [
            "x = [0] * N"
        ],
        "description": "greatest common divisor (最大公約数)"
    },
    "GCD": {
        "scope": "python",
        "prefix": "gcd",
        "body": [
            "def gcd(a, b):",
            "    if b == 0:",
            "        return a",
            "    return gcd(b, a % b)",
            "",
            "",
            "def gcd_n(a, n):",
            "    ans = a[0]",
            "    for i in range(1, n):",
            "        ans = gcd(ans, a[i])",
            "    return ans"
        ],
        "description": "greatest common divisor (最大公約数)"
    },
    "LCM": {
        "scope": "python",
        "prefix": "lcm",
        "body": [
            "def gcd(a, b):",
            "    if b == 0:",
            "        return a",
            "    return gcd(b, a % b)",
            "",
            "",
            "def lcm(a, b):",
            "    return a*b // gcd(a, b)",
            "",
            "",
            "def lcm_n(a, n):",
            "    ans = a[0]",
            "    for i in range(1, n):",
            "        ans = lcm(ans, A[i])",
            "    return ans"
        ],
        "description": "least common multiple (最小公倍数)"
    },
    "prime": {
        "scope": "python",
        "prefix": "prime",
        "body": [
            "def primes(n):",
            "    is_prime = [1] * (n + 1)",
            "    is_prime[0] = 0",
            "    is_prime[1] = 0",
            "    for i in range(2, int(n**0.5) + 1):",
            "        if not is_prime[i]:",
            "            continue",
            "        for j in range(i * 2, n + 1, i):",
            "            is_prime[j] = 0",
            "    return is_prime",
            "",
            "",
            "def is_prime(n):",
            "    if n == 1:",
            "        return False",
            "    for i in range(2, int(n**0.5)+1):",
            "        if n % i == 0:",
            "             return False",
            "    return True",
            "",
            "",
            "def gcd(a, b):",
            "    if b == 0:",
            "        return a",
            "    return gcd(b, a % b)",
            "",
            "",
            "def coprime(a, b):",
            "    return gcd(a, b) == 1"
        ],
        "description": "prime number (素数)"
    },
    "divisor": {
        "scope": "python",
        "prefix": "divisor",
        "body": [
            "def divisor(n):",
            "    ret = []",
            "    for i in range(1, int(n**0.5)+1):",
            "        if n % i == 0:",
            "            ret.append(i)",
            "            if n // i != i:",
            "                ret.append(n // i)",
            "    return ret",
        ],
        "description": "divisor (約数)"
    },
    "factorization": {
        "scope": "python",
        "prefix": "factorization",
        "body": [
            "def factorization(n):",
            "    if n <= 1:",
            "        return []",
            "",
            "    ret = []",
            "    while n > 2 and n % 2 == 0:",
            "        ret.append(2)",
            "        n //= 2",
            "    i = 3",
            "    while i <= math.sqrt(n):",
            "        if n % i == 0:",
            "            ret.append(i)",
            "            n //= i",
            "        else:",
            "            i += 2",
            "    ret.append(n)",
            "    return ret",
        ],
        "description": "factorization (素因数分解)"
    },
    "digsum": {
        "scope": "python",
        "prefix": "digsum",
        "body": [
            "def digsum(n):",
            "    s = 0",
            "    while n:",
            "        s += n % 10",
            "        n //= 10",
            "    return s",
        ],
        "description": "digsum (桁数)"
    },
    "modinv": {
        "scope": "python",
        "prefix": "modinv",
        "body": [
            "def modinv(a):",
            "    return pow(a, MOD-2, MOD)",
        ],
        "description": "modinv (MODの逆元)"
    },
    "bfs_graph": {
        "scope": "python",
        "prefix": "bfs_graph",
        "body": [
            "def bfs(graph, initial):",
            "    n = len(graph) - 1",
            "    dist = [-1] * (n + 1)",
            "    q = deque([initial])",
            "    visited = [False] * (n + 1)",
            "    visited[initial] = True",
            "    dist[initial] = 0",
            "",
            "    while len(q) != 0:",
            "        edge = q.popleft()",
            "        nxt = graph[edge]",
            "",
            "        for i, e in enumerate(nxt):",
            "            if visited[e] is False:",
            "                q.append(e)",
            "                dist[e] = dist[edge] + 1",
            "                visited[e] = True",
            "",
            "    return dist",
            "",
            "",
            "def main():",
            "    N, M = MI()",
            "    graph = [[] for i in range(N+1)]",
            "",
            "    for i in range(M):",
            "        x, y = MI()",
            "        graph[x].append(y)",
            "        graph[y].append(x)",
            "",
            "    ret = bfs(graph, 1)",
            "    print(ret)",
        ],
        "description": "BFS (graph)"
    },
    "bfs_maze": {
        "scope": "python",
        "prefix": "bfs_maze",
        "body": [
            "BLOCK = '#'",
            "ROAD = '.'",
            "",
            "",
            "def bfs(graph, initial, goal, H, W):",
            "    options = [(-1, 0), (0, 1), (1, 0), (0, -1)]",
            "    q = deque([initial])",
            "    visited = [[False for i in range(W)] for i in range(H)]",
            "    dist = [[-1 for i in range(W)] for i in range(H)]",
            "    visited[initial[0]][initial[1]] = True",
            "    dist[initial[0]][initial[1]] = 0",
            "",
            "    while len(q) != 0:",
            "        p = q.popleft()",
            "",
            "        for d in options:",
            "            i = p[0] + d[0]",
            "            j = p[1] + d[1]",
            "",
            "            if i >= 0 and i < H and j >= 0 and j < W and not visited[i][j] and graph[i][j] != BLOCK:",
            "                visited[i][j] = True",
            "                q.append((i, j))",
            "                dist[i][j] = dist[p[0]][p[1]] + 1",
            "",
            "    return dist[goal[0]][goal[1]]",
            "",
            "",
            "def main():",
            "    H, W = MI()",
            "    graph = [None] * H",
            "",
            "    for i in range(H):",
            "        graph[i] = list(S())",
            "",
            "        for j in range(W):",
            "            if graph[i][j] == 'S':",
            "                pass",
            "",
            "    ret = bfs(graph, (0, 0), (1, 1), H, W)",
            "    print(ret)",
        ],
        "description": "BFS (maze)"
    },
    "bfs_maze_hexa": {
        "scope": "python",
        "prefix": "bfs_maze_hexa",
        "body": [
            "def bfs(graph, initial, H, W):",
            "    odd_options = [(-1, 0), (-1, -1), (0, -1), (1, -1), (1, 0), (0, 1)]",
            "    even_options = [(-1, 0), (-1, 1), (0, 1), (1, 1), (1, 0), (0, -1)]",
            "    visited = [[False for i in range(W)] for i in range(H)]",
            "    dist = [[-1 for i in range(W)] for i in range(H)]",
            "    visited[initial[0]][initial[1]] = True",
            "    dist[initial[0]][initial[1]] = 0",
            "    q = deque([initial])",
            "",
            "    while len(q) != 0:",
            "        p = q.popleft()",
            "",
            "        options = even_options if p[0] % 2 == 0 else odd_options",
            "        for d in options:",
            "            i = p[0] + d[0]",
            "            j = p[1] + d[1]",
            "",
            "            if i >= 0 and i < H and j >= 0 and j < W and not visited[i][j] and graph[i][j] == 1:",
            "                visited[i][j] = True",
            "                q.append((i, j))",
            "                dist[i][j] = dist[p[0]][p[1]] + 1",
            "",
            "    return dist",
            "",
            "",
            "def main():",
            "    H, W = MI()",
            "    graph = [None] * H",
            "",
            "    for i in range(H):",
            "        graph[i] = LI()",
            "",
            "    ret = bfs(graph, (0, 1), H, W)",
            "    print(ret)",
        ],
        "description": "BFS (maze hexa)"
    },
    "dijkstra": {
        "scope": "python",
        "prefix": "dijkstra",
        "body": [
            "class NeighborList():",
            "    def __init__(self):",
            "        self.neighbor = {}",
            "",
            "class Dijkstra(object):",
            "    def dijkstra(self, adj, start, goal=None):",
            "        '''",
            "        ダイクストラアルゴリズムによる最短経路を求めるメソッド",
            "        入力",
            "        adj: adj[i][j]の値が頂点iから頂点jまでの距離(頂点iから頂点jに枝がない場合，値はfloat('inf'))となるような2次元リスト(正方行列)",
            "        start: 始点のID",
            "        goal: オプション引数．終点のID",
            "        出力",
            "        goalを引数に持つ場合，startからgoalまでの最短経路を格納したリストを返す",
            "        持たない場合は，startから各頂点までの最短距離を格納したリストを返す",
            "        '''",
            "        dist = {} # 始点から各頂点までの最短距離を格納する",
            "        prev = {} # 最短経路における，その頂点の前の頂点のIDを格納する",
            "",
            "        dist[start] = 0",
            "        prev[start] = 0",
            "        q = []                  # プライオリティキュー．各要素は，(startからある頂点vまでの仮の距離, 頂点vのID)からなるタプル",
            "        heappush(q, (0, start)) # 始点をpush",
            "",
            "        while len(q) != 0:",
            "            prov_cost, src = heappop(q) # pop",
            "",
            "            # プライオリティキューに格納されている最短距離が，現在計算できている最短距離より大きければ，distの更新をする必要はない",
            "            if dist[src] < prov_cost:",
            "                continue",
            "",
            "            # 他の頂点の探索",
            "            for dest in adj[src].neighbor.keys():",
            "                cost = adj[src].neighbor[dest]#src→destのチェック",
            "",
            "                if dest in dist.keys():",
            "                    if dist[dest] > dist[src] + cost:#先のコスト(仮決定) > 今のコスト+移動するのにかかるコスト",
            "                        dist[dest] = dist[src] + cost # distの更新",
            "                        heappush(q, (dist[dest], dest)) # キューに新たな仮の距離の情報をpush",
            "                        prev[dest] = src                      # 前の頂点IDを記録",
            "                else:#訪れたことが無ければ",
            "                    dist[dest] = dist[src] + cost # distの更新",
            "                    heappush(q, (dist[dest], dest)) # キューに新たな仮の距離の情報をpush",
            "                    prev[dest] = src                      # 前の頂点IDを記録",
            "",
            "        if goal is not None:",
            "            return self.get_path(start,goal, prev)",
            "        else:",
            "            return dist",
            "",
            "    def get_path(self, start, goal, prev):",
            "        '''",
            "        始点startから終点goalまでの最短経路を求める",
            "        '''",
            "        path = [goal]           # 最短経路",
            "        dest = goal",
            "",
            "        # 終点から最短経路を逆順に辿る",
            "        while prev[dest] != start:",
            "            path.append(prev[dest])",
            "            dest = prev[dest]",
            "",
            "        path.append(start)",
            "",
            "        # 経路をreverseして出力",
            "        return list(reversed(path))",
            "",
            "",
            "def main():",
            "    N, M = MI()",
            "    adj = {i:NeighborList() for i in range(N)}",
            "",
            "    for i in range(M):",
            "        A, B, C = MI()",
            "        A -= 1",
            "        B -= 1",
            "        adj[A].neighbor[B] = C",
            "        adj[B].neighbor[A] = C",
            "",
            "    d = Dijkstra()",
            "    ret = d.dijkstra(adj, 0)",
            "    print(ret)",
        ]
    },
    "bit_full_search": {
        "scope": "python",
        "prefix": "bit_full_search",
        "body": [
            "for i in range(2 ** N):",
            "    groups = set()",
            "    for j in range(N):",
            "        if ((i >> j) & 1):",
            "            groups.add(j+1)",
            "    pass",
        ],
        "description": "Bit Full Search"
    },
    "UnionFind": {
        "scope": "python",
        "prefix": "UnionFind",
        "body": [
            "class UnionFind(object):",
            "    def __init__(self, n):",
            "        self.n = n",
            "        self.parents = [-1] * n",
            "",
            "    def find(self, x):",
            "        if self.parents[x] < 0:",
            "            return x",
            "        else:",
            "            self.parents[x] = self.find(self.parents[x])",
            "            return self.parents[x]",
            "",
            "    def union(self, x, y):",
            "        x = self.find(x)",
            "        y = self.find(y)",
            "",
            "        if x == y:",
            "            return",
            "",
            "        if self.parents[x] > self.parents[y]:",
            "            x, y = y, x",
            "",
            "        self.parents[x] += self.parents[y]",
            "        self.parents[y] = x",
            "",
            "    def size(self, x):",
            "        return -self.parents[self.find(x)]",
            "",
            "    def same(self, x, y):",
            "        return self.find(x) == self.find(y)",
            "",
            "    def members(self, x):",
            "        root = self.find(x)",
            "        return [i for i in range(self.n) if self.find(i) == root]",
            "",
            "    def roots(self):",
            "        return [i for i, x in enumerate(self.parents) if x < 0]",
            "",
            "    def group_count(self):",
            "        return len(self.roots())",
            "",
            "    def all_group_members(self):",
            "        return {r: self.members(r) for r in self.roots()}",
            "",
            "    def __str__(self):",
            "        return '\\n'.join('{}: {}'.format(r, self.members(r)) for r in self.roots()),",
        ],
        "description": "Bit Full Search"
    },
    "cmb": {
        "scope": "python",
        "prefix": "cmb",
        "body": [
            "def cmb(n, r):",
            "    if n - r < r: r = n - r",
            "    if r == 0: return 1",
            "    if r == 1: return n",
            "",
            "    numerator = [n - r + k + 1 for k in range(r)]",
            "    denominator = [k + 1 for k in range(r)]",
            "",
            "    for p in range(2,r+1):",
            "        pivot = denominator[p - 1]",
            "        if pivot > 1:",
            "            offset = (n - r) % p",
            "            for k in range(p-1,r,p):",
            "                numerator[k - offset] /= pivot",
            "                denominator[k] /= pivot",
            "",
            "    result = 1",
            "    for k in range(r):",
            "        if numerator[k] > 1:",
            "            result *= int(numerator[k])",
            "",
            "    return result"
        ]
    },
    "cmb": {
        "scope": "python",
        "prefix": "cmb_modinv",
        "body": [
            "g1 = [1, 1]  # 元テーブル",
            "g2 = [1, 1]  # 逆元テーブル",
            "inverse = [0, 1]  # 逆元テーブル計算用テーブル",
            "",
            "",
            "# MOD 組み合わせ",
            "def cmb(n, r, mod):",
            "    if r < 0 or r > n:",
            "        return 0",
            "    r = min(r, n-r)",
            "    return g1[n] * g2[r] * g2[n-r] % mod",
            "",
            "",
            "def main():",
            "    N, M = MI()",
            "",
            "    for i in range(2, N + 1):",
            "        g1.append((g1[-1] * i) % MOD)",
            "        inverse.append((-inverse[MOD % i] * (MOD//i)) % MOD)",
            "        g2.append((g2[-1] * inverse[-1]) % MOD)",
        ]
    },
    "cmb_modinv2": {
        "scope": "python",
        "prefix": "cmb_modinv2",
        "body": [
            "def modinv(a):",
            "    return pow(a, MOD - 2, MOD)",
            "",
            "",
            "def cmb(n, r):",
            "    p = 1",
            "    c = 1",
            "    for i in range(r):",
            "        p *= (n - i)",
            "        c *= (i + 1)",
            "        p = p % MOD",
            "        c = c % MOD",
            "    return p * modinv(c) % MOD",
        ],
        "description": "Conbination mod inv"
    },
    "factorial_mod": {
        "scope": "python",
        "prefix": "factorial_mod",
        "body": [
            "def modinv(a):",
            "    return pow(a, MOD - 2, MOD)",
            "",
            "",
            "def factorial(n):",
            "    ret = 1",
            "    for i in range(1, n+1):",
            "        ret *= i",
            "        ret %= MOD",
            "    return ret",
        ],
        "description": "Conbination mod inv"
    },
    "warshall_floyd": {
        "scope": "python",
        "prefix": "warshall_floyd",
        "body": [
            "def warshall_floyd(d, n):",
            "    for k in range(n):",
            "        for i in range(n):",
            "            for j in range(n):",
            "                d[i][j] = min(d[i][j], d[i][k] + d[k][j])",
            "    return d",
            "",
            "",
            "def main():",
            "    N, M = MI()",
            "    d = [[IINF] * N for i in range(N)]",
            "",
            "    for i in range(M):",
            "        a, b, t = MI()",
            "        d[a-1][b-1] = t",
            "        d[b-1][a-1] = t",
            "",
            "    for i in range(N):",
            "        d[i][i] = 0",
            "",
            "    d = warshall_floyd(d, N)",
            "",
            "    print_matrix(d)",
        ],
        "description": "Warshall Floyd"
    },
    "doubling": {
        "scope": "python",
        "prefix": "doubling",
        "description": "doubling",
        "body": [
            "def main():",
            "    D = 60",
            "    N, K = MI()",
            "    A = LI()",
            "    to = [[0] * N for i in range(D)]",
            "",
            "    for i in range(N):",
            "        to[0][i] = A[i] - 1",
            "",
            "    for i in range(D-1):",
            "        for j in range(N):",
            "            to[i+1][j] = to[i][to[i][j]]",
            "",
            "    v = 0",
            "    for i in range(D-1, -1, -1):",
            "        l = 1 << i",
            "        if l <= K:",
            "            v = to[i][v]",
            "            K -= l",
            "",
            "    print(v+1)"
        ]
    },
    "lca": {
        "scope": "python",
        "prefix": "lca",
        "description": "Lowest Common Ancestor",
        "body": [
            "class LCA(object):",
            "    def __init__(self, G, root=0):",
            "        self.G = G",
            "        self.root = root",
            "        self.n = len(G)",
            "        self.logn = (self.n - 1).bit_length()",
            "        self.depth = [-1 if i != root else 0 for i in range(self.n)]",
            "        self.parent = [[-1] * self.n for _ in range(self.logn)]",
            "        self.dfs()",
            "        self.doubling()",
            "",
            "    def dfs(self):",
            "        que = [self.root]",
            "        while que:",
            "            u = que.pop()",
            "            for v in self.G[u]:",
            "                if self.depth[v] == -1:",
            "                    self.depth[v] = self.depth[u] + 1",
            "                    self.parent[0][v] = u",
            "                    que += [v]",
            "",
            "    def doubling(self):",
            "        for i in range(1, self.logn):",
            "            for v in range(self.n):",
            "                if self.parent[i - 1][v] != -1:",
            "                    self.parent[i][v] = self.parent[i - 1][self.parent[i - 1][v]]",
            "",
            "    def get(self, u, v):",
            "        if self.depth[v] < self.depth[u]:",
            "            u, v = v, u",
            "        du = self.depth[u]",
            "        dv = self.depth[v]",
            "",
            "        for i in range(self.logn):  # depthの差分だけuを遡らせる",
            "            if (dv - du) >> i & 1:",
            "                v = self.parent[i][v]",
            "        if u == v: return u  # 高さ揃えた時点で一致してたら終わり",
            "",
            "        for i in range(self.logn - 1, -1, -1):  # そうでなければ上から二分探索",
            "            pu, pv = self.parent[i][u], self.parent[i][v]",
            "            if pu != pv:",
            "                u, v = pu, pv",
            "        return self.parent[0][u]"
        ]
    },
    "distance": {
        "scope": "python",
        "prefix": "distance",
        "body": [
            "def distance(x1, y1, x2, y2):",
            "    return math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)",
        ],
        "description": "Warshall Floyd"
    },
    "binary_search": {
        "scope": "python",
        "prefix": "binary_search",
        "body": [
            "def f(x):",
            "    return x",
            "",
            "",
            "# 二分探索 ok ng",
            "def main():",
            "    A, B, X = MI()",
            "    s = 1",
            "    t = 10**9 + 1",
            "    ok = s - 1",
            "    ng = t",
            "",
            "    while ng - ok > 1:",
            "        mid = (ng + ok) // 2",
            "        if f(mid) <= X:",
            "            ok = mid",
            "        else:",
            "            ng = mid",
            "",
            "    print(ok)"
        ],
        "description": "Warshall Floyd"
    }
}
